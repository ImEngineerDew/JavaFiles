Codigo mío:

import java.util.Scanner;
import java.math.BigInteger;

public class recursivePrimes {
  public static void main(String args[]) {
    Scanner object = new Scanner(System.in);

    System.out.print("Please write the size of your array: ");
    Integer size = object.nextInt();

    BigInteger input[] = new BigInteger[size];
    boolean numberPrime[] = new boolean[size];
    readNumbers(input, numberPrime, object, 0);
    showNumbers(input, numberPrime, 0);
  }

  public static void readNumbers(BigInteger input[], boolean pri[], Scanner sc, Integer i) {
    if (!i.equals(input.length)) {
      BigInteger primes = sc.nextBigInteger();
      input[i] = primes;
      pri[i] = isPrime(primes, 2);
      readNumbers(input, pri, sc, i + 1);
    }
  }

  public static void showNumbers(BigInteger input[], boolean pri[], Integer j) {
    int compareJtoInput = j.compareTo(input.length);
    /** j<input.length **/
    if (compareJtoInput == -1) {
      BigInteger primes = input[j];
      BigInteger oMirp = backWards(primes);
      boolean isOmrip = isPrime(oMirp, 2) && isPrime(primes,2);
      //System.out.println(primes.toString() + " ");
      if (isOmrip) {
        System.out.println(oMirp.toString()+" is a prime of: "+primes.toString());
      } else {
        System.out.println(primes.toString()+" doesn't have an oMirp");
      }
      showNumbers(input, pri, j + 1);
    }
  }

  public static boolean isPrime(BigInteger num, int index) {
    /** List of variables that compare both values **/
    int numFor = num.intValue();
    int compareIfZero = num.compareTo(BigInteger.ZERO);
    int compareIfOne = num.compareTo(BigInteger.ONE);
    int compareIfFour = num.compareTo(BigInteger.valueOf(4));
    BigInteger modules = num.mod(BigInteger.valueOf(index));

    int compareModule = modules.compareTo(BigInteger.ZERO);

    /** This code line must compare between those issues **/
    if (compareIfZero == 0 || compareIfOne == 0 || compareIfFour == 0) {
      return false;
    }
    if (index >= ((numFor) / 2)) {
      return true;
    }
    if (compareModule == 0) {
      return false;
    }
    return isPrime(num, index + 1);
  }

  public static BigInteger backWards(BigInteger number) {
    int firstCompare = number.compareTo(BigInteger.valueOf(10));
    /**Check if the number is minus than 10**/
    if (firstCompare == -1) {
      return number;
      /**If the number is greater than 10, then flip the number **/
    } else {
      String reversedString = "";
      BigInteger reversedNumber;
      reversedString = reversedString.concat(number.mod(BigInteger.valueOf(10)).toString());
      reversedNumber = backWards(number.divide(BigInteger.valueOf(10)));
      reversedString = reversedString.concat(reversedNumber.toString());
      return new BigInteger(reversedString);
    }
  }
}

Código tuyo:

import java.math.BigInteger;
import java.util.Scanner;

public class EmirpPrime {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Ingrese el tamaño del arreglo: ");
        int size = scanner.nextInt();
        BigInteger[] array = new BigInteger[size];
        System.out.println("Ingrese los números: ");
        for (int i = 0; i < size; i++) {
            array[i] = scanner.nextBigInteger();
        }
        for (int i = 0; i < size; i++) {
            BigInteger res = emirpPrime(array[i]);
            System.out.println(res);
        }
    }

    public static BigInteger emirpPrime(BigInteger x) {
        BigInteger res = isPrime(x);
        return res;
    }

    public static BigInteger isPrime(BigInteger x) {
        boolean check = x.isProbablePrime(10);
        if (check) {
            return isEmirp(x);
        } else {
            return isPrime(x.nextProbablePrime());
        }
    }

    public static BigInteger isEmirp(BigInteger prime) {
        BigInteger emirp = new BigInteger(new StringBuilder(prime.toString()).reverse().toString());
        boolean check = emirp.isProbablePrime(10);
        if (check) {
            return prime;
        } else {
            return isPrime(primeScape(prime.nextProbablePrime()));
        }
    }

    public static BigInteger primeScape(BigInteger prime) {
        switch (prime.toString().substring(0, 1)) {
            case "2":
                return new BigInteger("30000000000000000000047");
            case "4":
            case "5":
            case "6":
                return new BigInteger("70000000000000000000859");
            case "8":
                return new BigInteger("90000000000000000000001");
            default:
                return prime;
        }
    }
}

¿Cuál es el código resultante para que me imprima la misma salida, y se comporte igual que tu código?